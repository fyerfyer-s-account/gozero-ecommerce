// Code generated by mockery v2.50.0. DO NOT EDIT.

package cart

import (
	cart "github.com/fyerfyer/gozero-ecommerce/ecommerce/cart/rpc/cart"

	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// Cart is an autogenerated mock type for the Cart type
type Cart struct {
	mock.Mock
}

type Cart_Expecter struct {
	mock *mock.Mock
}

func (_m *Cart) EXPECT() *Cart_Expecter {
	return &Cart_Expecter{mock: &_m.Mock}
}

// AddItem provides a mock function with given fields: ctx, in, opts
func (_m *Cart) AddItem(ctx context.Context, in *cart.AddItemRequest, opts ...grpc.CallOption) (*cart.AddItemResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddItem")
	}

	var r0 *cart.AddItemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.AddItemRequest, ...grpc.CallOption) (*cart.AddItemResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.AddItemRequest, ...grpc.CallOption) *cart.AddItemResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.AddItemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.AddItemRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_AddItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddItem'
type Cart_AddItem_Call struct {
	*mock.Call
}

// AddItem is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.AddItemRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) AddItem(ctx interface{}, in interface{}, opts ...interface{}) *Cart_AddItem_Call {
	return &Cart_AddItem_Call{Call: _e.mock.On("AddItem",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_AddItem_Call) Run(run func(ctx context.Context, in *cart.AddItemRequest, opts ...grpc.CallOption)) *Cart_AddItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.AddItemRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_AddItem_Call) Return(_a0 *cart.AddItemResponse, _a1 error) *Cart_AddItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_AddItem_Call) RunAndReturn(run func(context.Context, *cart.AddItemRequest, ...grpc.CallOption) (*cart.AddItemResponse, error)) *Cart_AddItem_Call {
	_c.Call.Return(run)
	return _c
}

// CheckStock provides a mock function with given fields: ctx, in, opts
func (_m *Cart) CheckStock(ctx context.Context, in *cart.CheckStockRequest, opts ...grpc.CallOption) (*cart.CheckStockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckStock")
	}

	var r0 *cart.CheckStockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.CheckStockRequest, ...grpc.CallOption) (*cart.CheckStockResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.CheckStockRequest, ...grpc.CallOption) *cart.CheckStockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.CheckStockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.CheckStockRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_CheckStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckStock'
type Cart_CheckStock_Call struct {
	*mock.Call
}

// CheckStock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.CheckStockRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) CheckStock(ctx interface{}, in interface{}, opts ...interface{}) *Cart_CheckStock_Call {
	return &Cart_CheckStock_Call{Call: _e.mock.On("CheckStock",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_CheckStock_Call) Run(run func(ctx context.Context, in *cart.CheckStockRequest, opts ...grpc.CallOption)) *Cart_CheckStock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.CheckStockRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_CheckStock_Call) Return(_a0 *cart.CheckStockResponse, _a1 error) *Cart_CheckStock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_CheckStock_Call) RunAndReturn(run func(context.Context, *cart.CheckStockRequest, ...grpc.CallOption) (*cart.CheckStockResponse, error)) *Cart_CheckStock_Call {
	_c.Call.Return(run)
	return _c
}

// ClearCart provides a mock function with given fields: ctx, in, opts
func (_m *Cart) ClearCart(ctx context.Context, in *cart.ClearCartRequest, opts ...grpc.CallOption) (*cart.ClearCartResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClearCart")
	}

	var r0 *cart.ClearCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.ClearCartRequest, ...grpc.CallOption) (*cart.ClearCartResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.ClearCartRequest, ...grpc.CallOption) *cart.ClearCartResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.ClearCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.ClearCartRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_ClearCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearCart'
type Cart_ClearCart_Call struct {
	*mock.Call
}

// ClearCart is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.ClearCartRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) ClearCart(ctx interface{}, in interface{}, opts ...interface{}) *Cart_ClearCart_Call {
	return &Cart_ClearCart_Call{Call: _e.mock.On("ClearCart",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_ClearCart_Call) Run(run func(ctx context.Context, in *cart.ClearCartRequest, opts ...grpc.CallOption)) *Cart_ClearCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.ClearCartRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_ClearCart_Call) Return(_a0 *cart.ClearCartResponse, _a1 error) *Cart_ClearCart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_ClearCart_Call) RunAndReturn(run func(context.Context, *cart.ClearCartRequest, ...grpc.CallOption) (*cart.ClearCartResponse, error)) *Cart_ClearCart_Call {
	_c.Call.Return(run)
	return _c
}

// GetCart provides a mock function with given fields: ctx, in, opts
func (_m *Cart) GetCart(ctx context.Context, in *cart.GetCartRequest, opts ...grpc.CallOption) (*cart.GetCartResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCart")
	}

	var r0 *cart.GetCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.GetCartRequest, ...grpc.CallOption) (*cart.GetCartResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.GetCartRequest, ...grpc.CallOption) *cart.GetCartResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.GetCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.GetCartRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_GetCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCart'
type Cart_GetCart_Call struct {
	*mock.Call
}

// GetCart is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.GetCartRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) GetCart(ctx interface{}, in interface{}, opts ...interface{}) *Cart_GetCart_Call {
	return &Cart_GetCart_Call{Call: _e.mock.On("GetCart",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_GetCart_Call) Run(run func(ctx context.Context, in *cart.GetCartRequest, opts ...grpc.CallOption)) *Cart_GetCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.GetCartRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_GetCart_Call) Return(_a0 *cart.GetCartResponse, _a1 error) *Cart_GetCart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_GetCart_Call) RunAndReturn(run func(context.Context, *cart.GetCartRequest, ...grpc.CallOption) (*cart.GetCartResponse, error)) *Cart_GetCart_Call {
	_c.Call.Return(run)
	return _c
}

// GetSelectedItems provides a mock function with given fields: ctx, in, opts
func (_m *Cart) GetSelectedItems(ctx context.Context, in *cart.GetSelectedItemsRequest, opts ...grpc.CallOption) (*cart.GetSelectedItemsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSelectedItems")
	}

	var r0 *cart.GetSelectedItemsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.GetSelectedItemsRequest, ...grpc.CallOption) (*cart.GetSelectedItemsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.GetSelectedItemsRequest, ...grpc.CallOption) *cart.GetSelectedItemsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.GetSelectedItemsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.GetSelectedItemsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_GetSelectedItems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSelectedItems'
type Cart_GetSelectedItems_Call struct {
	*mock.Call
}

// GetSelectedItems is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.GetSelectedItemsRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) GetSelectedItems(ctx interface{}, in interface{}, opts ...interface{}) *Cart_GetSelectedItems_Call {
	return &Cart_GetSelectedItems_Call{Call: _e.mock.On("GetSelectedItems",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_GetSelectedItems_Call) Run(run func(ctx context.Context, in *cart.GetSelectedItemsRequest, opts ...grpc.CallOption)) *Cart_GetSelectedItems_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.GetSelectedItemsRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_GetSelectedItems_Call) Return(_a0 *cart.GetSelectedItemsResponse, _a1 error) *Cart_GetSelectedItems_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_GetSelectedItems_Call) RunAndReturn(run func(context.Context, *cart.GetSelectedItemsRequest, ...grpc.CallOption) (*cart.GetSelectedItemsResponse, error)) *Cart_GetSelectedItems_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveItem provides a mock function with given fields: ctx, in, opts
func (_m *Cart) RemoveItem(ctx context.Context, in *cart.RemoveItemRequest, opts ...grpc.CallOption) (*cart.RemoveItemResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveItem")
	}

	var r0 *cart.RemoveItemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.RemoveItemRequest, ...grpc.CallOption) (*cart.RemoveItemResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.RemoveItemRequest, ...grpc.CallOption) *cart.RemoveItemResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.RemoveItemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.RemoveItemRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_RemoveItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveItem'
type Cart_RemoveItem_Call struct {
	*mock.Call
}

// RemoveItem is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.RemoveItemRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) RemoveItem(ctx interface{}, in interface{}, opts ...interface{}) *Cart_RemoveItem_Call {
	return &Cart_RemoveItem_Call{Call: _e.mock.On("RemoveItem",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_RemoveItem_Call) Run(run func(ctx context.Context, in *cart.RemoveItemRequest, opts ...grpc.CallOption)) *Cart_RemoveItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.RemoveItemRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_RemoveItem_Call) Return(_a0 *cart.RemoveItemResponse, _a1 error) *Cart_RemoveItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_RemoveItem_Call) RunAndReturn(run func(context.Context, *cart.RemoveItemRequest, ...grpc.CallOption) (*cart.RemoveItemResponse, error)) *Cart_RemoveItem_Call {
	_c.Call.Return(run)
	return _c
}

// SelectAll provides a mock function with given fields: ctx, in, opts
func (_m *Cart) SelectAll(ctx context.Context, in *cart.SelectAllRequest, opts ...grpc.CallOption) (*cart.SelectAllResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelectAll")
	}

	var r0 *cart.SelectAllResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.SelectAllRequest, ...grpc.CallOption) (*cart.SelectAllResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.SelectAllRequest, ...grpc.CallOption) *cart.SelectAllResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.SelectAllResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.SelectAllRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_SelectAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectAll'
type Cart_SelectAll_Call struct {
	*mock.Call
}

// SelectAll is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.SelectAllRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) SelectAll(ctx interface{}, in interface{}, opts ...interface{}) *Cart_SelectAll_Call {
	return &Cart_SelectAll_Call{Call: _e.mock.On("SelectAll",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_SelectAll_Call) Run(run func(ctx context.Context, in *cart.SelectAllRequest, opts ...grpc.CallOption)) *Cart_SelectAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.SelectAllRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_SelectAll_Call) Return(_a0 *cart.SelectAllResponse, _a1 error) *Cart_SelectAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_SelectAll_Call) RunAndReturn(run func(context.Context, *cart.SelectAllRequest, ...grpc.CallOption) (*cart.SelectAllResponse, error)) *Cart_SelectAll_Call {
	_c.Call.Return(run)
	return _c
}

// SelectItem provides a mock function with given fields: ctx, in, opts
func (_m *Cart) SelectItem(ctx context.Context, in *cart.SelectItemRequest, opts ...grpc.CallOption) (*cart.SelectItemResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelectItem")
	}

	var r0 *cart.SelectItemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.SelectItemRequest, ...grpc.CallOption) (*cart.SelectItemResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.SelectItemRequest, ...grpc.CallOption) *cart.SelectItemResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.SelectItemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.SelectItemRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_SelectItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectItem'
type Cart_SelectItem_Call struct {
	*mock.Call
}

// SelectItem is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.SelectItemRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) SelectItem(ctx interface{}, in interface{}, opts ...interface{}) *Cart_SelectItem_Call {
	return &Cart_SelectItem_Call{Call: _e.mock.On("SelectItem",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_SelectItem_Call) Run(run func(ctx context.Context, in *cart.SelectItemRequest, opts ...grpc.CallOption)) *Cart_SelectItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.SelectItemRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_SelectItem_Call) Return(_a0 *cart.SelectItemResponse, _a1 error) *Cart_SelectItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_SelectItem_Call) RunAndReturn(run func(context.Context, *cart.SelectItemRequest, ...grpc.CallOption) (*cart.SelectItemResponse, error)) *Cart_SelectItem_Call {
	_c.Call.Return(run)
	return _c
}

// UnselectAll provides a mock function with given fields: ctx, in, opts
func (_m *Cart) UnselectAll(ctx context.Context, in *cart.UnselectAllRequest, opts ...grpc.CallOption) (*cart.UnselectAllResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnselectAll")
	}

	var r0 *cart.UnselectAllResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.UnselectAllRequest, ...grpc.CallOption) (*cart.UnselectAllResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.UnselectAllRequest, ...grpc.CallOption) *cart.UnselectAllResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.UnselectAllResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.UnselectAllRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_UnselectAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnselectAll'
type Cart_UnselectAll_Call struct {
	*mock.Call
}

// UnselectAll is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.UnselectAllRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) UnselectAll(ctx interface{}, in interface{}, opts ...interface{}) *Cart_UnselectAll_Call {
	return &Cart_UnselectAll_Call{Call: _e.mock.On("UnselectAll",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_UnselectAll_Call) Run(run func(ctx context.Context, in *cart.UnselectAllRequest, opts ...grpc.CallOption)) *Cart_UnselectAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.UnselectAllRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_UnselectAll_Call) Return(_a0 *cart.UnselectAllResponse, _a1 error) *Cart_UnselectAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_UnselectAll_Call) RunAndReturn(run func(context.Context, *cart.UnselectAllRequest, ...grpc.CallOption) (*cart.UnselectAllResponse, error)) *Cart_UnselectAll_Call {
	_c.Call.Return(run)
	return _c
}

// UnselectItem provides a mock function with given fields: ctx, in, opts
func (_m *Cart) UnselectItem(ctx context.Context, in *cart.UnselectItemRequest, opts ...grpc.CallOption) (*cart.UnselectItemResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnselectItem")
	}

	var r0 *cart.UnselectItemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.UnselectItemRequest, ...grpc.CallOption) (*cart.UnselectItemResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.UnselectItemRequest, ...grpc.CallOption) *cart.UnselectItemResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.UnselectItemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.UnselectItemRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_UnselectItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnselectItem'
type Cart_UnselectItem_Call struct {
	*mock.Call
}

// UnselectItem is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.UnselectItemRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) UnselectItem(ctx interface{}, in interface{}, opts ...interface{}) *Cart_UnselectItem_Call {
	return &Cart_UnselectItem_Call{Call: _e.mock.On("UnselectItem",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_UnselectItem_Call) Run(run func(ctx context.Context, in *cart.UnselectItemRequest, opts ...grpc.CallOption)) *Cart_UnselectItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.UnselectItemRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_UnselectItem_Call) Return(_a0 *cart.UnselectItemResponse, _a1 error) *Cart_UnselectItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_UnselectItem_Call) RunAndReturn(run func(context.Context, *cart.UnselectItemRequest, ...grpc.CallOption) (*cart.UnselectItemResponse, error)) *Cart_UnselectItem_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateItem provides a mock function with given fields: ctx, in, opts
func (_m *Cart) UpdateItem(ctx context.Context, in *cart.UpdateItemRequest, opts ...grpc.CallOption) (*cart.UpdateItemResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateItem")
	}

	var r0 *cart.UpdateItemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cart.UpdateItemRequest, ...grpc.CallOption) (*cart.UpdateItemResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cart.UpdateItemRequest, ...grpc.CallOption) *cart.UpdateItemResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cart.UpdateItemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cart.UpdateItemRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cart_UpdateItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateItem'
type Cart_UpdateItem_Call struct {
	*mock.Call
}

// UpdateItem is a helper method to define mock.On call
//   - ctx context.Context
//   - in *cart.UpdateItemRequest
//   - opts ...grpc.CallOption
func (_e *Cart_Expecter) UpdateItem(ctx interface{}, in interface{}, opts ...interface{}) *Cart_UpdateItem_Call {
	return &Cart_UpdateItem_Call{Call: _e.mock.On("UpdateItem",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *Cart_UpdateItem_Call) Run(run func(ctx context.Context, in *cart.UpdateItemRequest, opts ...grpc.CallOption)) *Cart_UpdateItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*cart.UpdateItemRequest), variadicArgs...)
	})
	return _c
}

func (_c *Cart_UpdateItem_Call) Return(_a0 *cart.UpdateItemResponse, _a1 error) *Cart_UpdateItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cart_UpdateItem_Call) RunAndReturn(run func(context.Context, *cart.UpdateItemRequest, ...grpc.CallOption) (*cart.UpdateItemResponse, error)) *Cart_UpdateItem_Call {
	_c.Call.Return(run)
	return _c
}

// NewCart creates a new instance of Cart. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCart(t interface {
	mock.TestingT
	Cleanup(func())
}) *Cart {
	mock := &Cart{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
