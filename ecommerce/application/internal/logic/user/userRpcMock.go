// Code generated by mockery v2.50.0. DO NOT EDIT.

package user

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	user "github.com/fyerfyer/gozero-ecommerce/ecommerce/user/rpc/user"
)

// User is an autogenerated mock type for the User type
type User struct {
	mock.Mock
}

type User_Expecter struct {
	mock *mock.Mock
}

func (_m *User) EXPECT() *User_Expecter {
	return &User_Expecter{mock: &_m.Mock}
}

// AddAddress provides a mock function with given fields: ctx, in, opts
func (_m *User) AddAddress(ctx context.Context, in *user.AddAddressRequest, opts ...grpc.CallOption) (*user.AddAddressResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddAddress")
	}

	var r0 *user.AddAddressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.AddAddressRequest, ...grpc.CallOption) (*user.AddAddressResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.AddAddressRequest, ...grpc.CallOption) *user.AddAddressResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.AddAddressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.AddAddressRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_AddAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAddress'
type User_AddAddress_Call struct {
	*mock.Call
}

// AddAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.AddAddressRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) AddAddress(ctx interface{}, in interface{}, opts ...interface{}) *User_AddAddress_Call {
	return &User_AddAddress_Call{Call: _e.mock.On("AddAddress",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_AddAddress_Call) Run(run func(ctx context.Context, in *user.AddAddressRequest, opts ...grpc.CallOption)) *User_AddAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.AddAddressRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_AddAddress_Call) Return(_a0 *user.AddAddressResponse, _a1 error) *User_AddAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_AddAddress_Call) RunAndReturn(run func(context.Context, *user.AddAddressRequest, ...grpc.CallOption) (*user.AddAddressResponse, error)) *User_AddAddress_Call {
	_c.Call.Return(run)
	return _c
}

// ChangePassword provides a mock function with given fields: ctx, in, opts
func (_m *User) ChangePassword(ctx context.Context, in *user.ChangePasswordRequest, opts ...grpc.CallOption) (*user.ChangePasswordResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangePassword")
	}

	var r0 *user.ChangePasswordResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.ChangePasswordRequest, ...grpc.CallOption) (*user.ChangePasswordResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.ChangePasswordRequest, ...grpc.CallOption) *user.ChangePasswordResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.ChangePasswordResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.ChangePasswordRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_ChangePassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangePassword'
type User_ChangePassword_Call struct {
	*mock.Call
}

// ChangePassword is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.ChangePasswordRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) ChangePassword(ctx interface{}, in interface{}, opts ...interface{}) *User_ChangePassword_Call {
	return &User_ChangePassword_Call{Call: _e.mock.On("ChangePassword",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_ChangePassword_Call) Run(run func(ctx context.Context, in *user.ChangePasswordRequest, opts ...grpc.CallOption)) *User_ChangePassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.ChangePasswordRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_ChangePassword_Call) Return(_a0 *user.ChangePasswordResponse, _a1 error) *User_ChangePassword_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_ChangePassword_Call) RunAndReturn(run func(context.Context, *user.ChangePasswordRequest, ...grpc.CallOption) (*user.ChangePasswordResponse, error)) *User_ChangePassword_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAddress provides a mock function with given fields: ctx, in, opts
func (_m *User) DeleteAddress(ctx context.Context, in *user.DeleteAddressRequest, opts ...grpc.CallOption) (*user.DeleteAddressResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAddress")
	}

	var r0 *user.DeleteAddressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.DeleteAddressRequest, ...grpc.CallOption) (*user.DeleteAddressResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.DeleteAddressRequest, ...grpc.CallOption) *user.DeleteAddressResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.DeleteAddressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.DeleteAddressRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_DeleteAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAddress'
type User_DeleteAddress_Call struct {
	*mock.Call
}

// DeleteAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.DeleteAddressRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) DeleteAddress(ctx interface{}, in interface{}, opts ...interface{}) *User_DeleteAddress_Call {
	return &User_DeleteAddress_Call{Call: _e.mock.On("DeleteAddress",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_DeleteAddress_Call) Run(run func(ctx context.Context, in *user.DeleteAddressRequest, opts ...grpc.CallOption)) *User_DeleteAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.DeleteAddressRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_DeleteAddress_Call) Return(_a0 *user.DeleteAddressResponse, _a1 error) *User_DeleteAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_DeleteAddress_Call) RunAndReturn(run func(context.Context, *user.DeleteAddressRequest, ...grpc.CallOption) (*user.DeleteAddressResponse, error)) *User_DeleteAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactions provides a mock function with given fields: ctx, in, opts
func (_m *User) GetTransactions(ctx context.Context, in *user.GetTransactionsRequest, opts ...grpc.CallOption) (*user.GetTransactionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactions")
	}

	var r0 *user.GetTransactionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetTransactionsRequest, ...grpc.CallOption) (*user.GetTransactionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetTransactionsRequest, ...grpc.CallOption) *user.GetTransactionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.GetTransactionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.GetTransactionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_GetTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactions'
type User_GetTransactions_Call struct {
	*mock.Call
}

// GetTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.GetTransactionsRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) GetTransactions(ctx interface{}, in interface{}, opts ...interface{}) *User_GetTransactions_Call {
	return &User_GetTransactions_Call{Call: _e.mock.On("GetTransactions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_GetTransactions_Call) Run(run func(ctx context.Context, in *user.GetTransactionsRequest, opts ...grpc.CallOption)) *User_GetTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.GetTransactionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_GetTransactions_Call) Return(_a0 *user.GetTransactionsResponse, _a1 error) *User_GetTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_GetTransactions_Call) RunAndReturn(run func(context.Context, *user.GetTransactionsRequest, ...grpc.CallOption) (*user.GetTransactionsResponse, error)) *User_GetTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAddresses provides a mock function with given fields: ctx, in, opts
func (_m *User) GetUserAddresses(ctx context.Context, in *user.GetUserAddressesRequest, opts ...grpc.CallOption) (*user.GetUserAddressesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAddresses")
	}

	var r0 *user.GetUserAddressesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetUserAddressesRequest, ...grpc.CallOption) (*user.GetUserAddressesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetUserAddressesRequest, ...grpc.CallOption) *user.GetUserAddressesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.GetUserAddressesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.GetUserAddressesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_GetUserAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAddresses'
type User_GetUserAddresses_Call struct {
	*mock.Call
}

// GetUserAddresses is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.GetUserAddressesRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) GetUserAddresses(ctx interface{}, in interface{}, opts ...interface{}) *User_GetUserAddresses_Call {
	return &User_GetUserAddresses_Call{Call: _e.mock.On("GetUserAddresses",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_GetUserAddresses_Call) Run(run func(ctx context.Context, in *user.GetUserAddressesRequest, opts ...grpc.CallOption)) *User_GetUserAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.GetUserAddressesRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_GetUserAddresses_Call) Return(_a0 *user.GetUserAddressesResponse, _a1 error) *User_GetUserAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_GetUserAddresses_Call) RunAndReturn(run func(context.Context, *user.GetUserAddressesRequest, ...grpc.CallOption) (*user.GetUserAddressesResponse, error)) *User_GetUserAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserInfo provides a mock function with given fields: ctx, in, opts
func (_m *User) GetUserInfo(ctx context.Context, in *user.GetUserInfoRequest, opts ...grpc.CallOption) (*user.GetUserInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserInfo")
	}

	var r0 *user.GetUserInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetUserInfoRequest, ...grpc.CallOption) (*user.GetUserInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetUserInfoRequest, ...grpc.CallOption) *user.GetUserInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.GetUserInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.GetUserInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_GetUserInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserInfo'
type User_GetUserInfo_Call struct {
	*mock.Call
}

// GetUserInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.GetUserInfoRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) GetUserInfo(ctx interface{}, in interface{}, opts ...interface{}) *User_GetUserInfo_Call {
	return &User_GetUserInfo_Call{Call: _e.mock.On("GetUserInfo",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_GetUserInfo_Call) Run(run func(ctx context.Context, in *user.GetUserInfoRequest, opts ...grpc.CallOption)) *User_GetUserInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.GetUserInfoRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_GetUserInfo_Call) Return(_a0 *user.GetUserInfoResponse, _a1 error) *User_GetUserInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_GetUserInfo_Call) RunAndReturn(run func(context.Context, *user.GetUserInfoRequest, ...grpc.CallOption) (*user.GetUserInfoResponse, error)) *User_GetUserInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetWallet provides a mock function with given fields: ctx, in, opts
func (_m *User) GetWallet(ctx context.Context, in *user.GetWalletRequest, opts ...grpc.CallOption) (*user.GetWalletResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWallet")
	}

	var r0 *user.GetWalletResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetWalletRequest, ...grpc.CallOption) (*user.GetWalletResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.GetWalletRequest, ...grpc.CallOption) *user.GetWalletResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.GetWalletResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.GetWalletRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_GetWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWallet'
type User_GetWallet_Call struct {
	*mock.Call
}

// GetWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.GetWalletRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) GetWallet(ctx interface{}, in interface{}, opts ...interface{}) *User_GetWallet_Call {
	return &User_GetWallet_Call{Call: _e.mock.On("GetWallet",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_GetWallet_Call) Run(run func(ctx context.Context, in *user.GetWalletRequest, opts ...grpc.CallOption)) *User_GetWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.GetWalletRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_GetWallet_Call) Return(_a0 *user.GetWalletResponse, _a1 error) *User_GetWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_GetWallet_Call) RunAndReturn(run func(context.Context, *user.GetWalletRequest, ...grpc.CallOption) (*user.GetWalletResponse, error)) *User_GetWallet_Call {
	_c.Call.Return(run)
	return _c
}

// Login provides a mock function with given fields: ctx, in, opts
func (_m *User) Login(ctx context.Context, in *user.LoginRequest, opts ...grpc.CallOption) (*user.LoginResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Login")
	}

	var r0 *user.LoginResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.LoginRequest, ...grpc.CallOption) (*user.LoginResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.LoginRequest, ...grpc.CallOption) *user.LoginResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.LoginResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.LoginRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type User_Login_Call struct {
	*mock.Call
}

// Login is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.LoginRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) Login(ctx interface{}, in interface{}, opts ...interface{}) *User_Login_Call {
	return &User_Login_Call{Call: _e.mock.On("Login",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_Login_Call) Run(run func(ctx context.Context, in *user.LoginRequest, opts ...grpc.CallOption)) *User_Login_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.LoginRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_Login_Call) Return(_a0 *user.LoginResponse, _a1 error) *User_Login_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_Login_Call) RunAndReturn(run func(context.Context, *user.LoginRequest, ...grpc.CallOption) (*user.LoginResponse, error)) *User_Login_Call {
	_c.Call.Return(run)
	return _c
}

// Logout provides a mock function with given fields: ctx, in, opts
func (_m *User) Logout(ctx context.Context, in *user.LogoutRequest, opts ...grpc.CallOption) (*user.LogoutResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Logout")
	}

	var r0 *user.LogoutResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.LogoutRequest, ...grpc.CallOption) (*user.LogoutResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.LogoutRequest, ...grpc.CallOption) *user.LogoutResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.LogoutResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.LogoutRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_Logout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logout'
type User_Logout_Call struct {
	*mock.Call
}

// Logout is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.LogoutRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) Logout(ctx interface{}, in interface{}, opts ...interface{}) *User_Logout_Call {
	return &User_Logout_Call{Call: _e.mock.On("Logout",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_Logout_Call) Run(run func(ctx context.Context, in *user.LogoutRequest, opts ...grpc.CallOption)) *User_Logout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.LogoutRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_Logout_Call) Return(_a0 *user.LogoutResponse, _a1 error) *User_Logout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_Logout_Call) RunAndReturn(run func(context.Context, *user.LogoutRequest, ...grpc.CallOption) (*user.LogoutResponse, error)) *User_Logout_Call {
	_c.Call.Return(run)
	return _c
}

// RechargeWallet provides a mock function with given fields: ctx, in, opts
func (_m *User) RechargeWallet(ctx context.Context, in *user.RechargeWalletRequest, opts ...grpc.CallOption) (*user.RechargeWalletResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RechargeWallet")
	}

	var r0 *user.RechargeWalletResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.RechargeWalletRequest, ...grpc.CallOption) (*user.RechargeWalletResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.RechargeWalletRequest, ...grpc.CallOption) *user.RechargeWalletResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.RechargeWalletResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.RechargeWalletRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_RechargeWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RechargeWallet'
type User_RechargeWallet_Call struct {
	*mock.Call
}

// RechargeWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.RechargeWalletRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) RechargeWallet(ctx interface{}, in interface{}, opts ...interface{}) *User_RechargeWallet_Call {
	return &User_RechargeWallet_Call{Call: _e.mock.On("RechargeWallet",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_RechargeWallet_Call) Run(run func(ctx context.Context, in *user.RechargeWalletRequest, opts ...grpc.CallOption)) *User_RechargeWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.RechargeWalletRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_RechargeWallet_Call) Return(_a0 *user.RechargeWalletResponse, _a1 error) *User_RechargeWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_RechargeWallet_Call) RunAndReturn(run func(context.Context, *user.RechargeWalletRequest, ...grpc.CallOption) (*user.RechargeWalletResponse, error)) *User_RechargeWallet_Call {
	_c.Call.Return(run)
	return _c
}

// Register provides a mock function with given fields: ctx, in, opts
func (_m *User) Register(ctx context.Context, in *user.RegisterRequest, opts ...grpc.CallOption) (*user.RegisterResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 *user.RegisterResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.RegisterRequest, ...grpc.CallOption) (*user.RegisterResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.RegisterRequest, ...grpc.CallOption) *user.RegisterResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.RegisterResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.RegisterRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type User_Register_Call struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.RegisterRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) Register(ctx interface{}, in interface{}, opts ...interface{}) *User_Register_Call {
	return &User_Register_Call{Call: _e.mock.On("Register",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_Register_Call) Run(run func(ctx context.Context, in *user.RegisterRequest, opts ...grpc.CallOption)) *User_Register_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.RegisterRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_Register_Call) Return(_a0 *user.RegisterResponse, _a1 error) *User_Register_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_Register_Call) RunAndReturn(run func(context.Context, *user.RegisterRequest, ...grpc.CallOption) (*user.RegisterResponse, error)) *User_Register_Call {
	_c.Call.Return(run)
	return _c
}

// ResetPassword provides a mock function with given fields: ctx, in, opts
func (_m *User) ResetPassword(ctx context.Context, in *user.ResetPasswordRequest, opts ...grpc.CallOption) (*user.ResetPasswordResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetPassword")
	}

	var r0 *user.ResetPasswordResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.ResetPasswordRequest, ...grpc.CallOption) (*user.ResetPasswordResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.ResetPasswordRequest, ...grpc.CallOption) *user.ResetPasswordResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.ResetPasswordResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.ResetPasswordRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_ResetPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetPassword'
type User_ResetPassword_Call struct {
	*mock.Call
}

// ResetPassword is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.ResetPasswordRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) ResetPassword(ctx interface{}, in interface{}, opts ...interface{}) *User_ResetPassword_Call {
	return &User_ResetPassword_Call{Call: _e.mock.On("ResetPassword",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_ResetPassword_Call) Run(run func(ctx context.Context, in *user.ResetPasswordRequest, opts ...grpc.CallOption)) *User_ResetPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.ResetPasswordRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_ResetPassword_Call) Return(_a0 *user.ResetPasswordResponse, _a1 error) *User_ResetPassword_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_ResetPassword_Call) RunAndReturn(run func(context.Context, *user.ResetPasswordRequest, ...grpc.CallOption) (*user.ResetPasswordResponse, error)) *User_ResetPassword_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAddress provides a mock function with given fields: ctx, in, opts
func (_m *User) UpdateAddress(ctx context.Context, in *user.UpdateAddressRequest, opts ...grpc.CallOption) (*user.UpdateAddressResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAddress")
	}

	var r0 *user.UpdateAddressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.UpdateAddressRequest, ...grpc.CallOption) (*user.UpdateAddressResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.UpdateAddressRequest, ...grpc.CallOption) *user.UpdateAddressResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.UpdateAddressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.UpdateAddressRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_UpdateAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAddress'
type User_UpdateAddress_Call struct {
	*mock.Call
}

// UpdateAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.UpdateAddressRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) UpdateAddress(ctx interface{}, in interface{}, opts ...interface{}) *User_UpdateAddress_Call {
	return &User_UpdateAddress_Call{Call: _e.mock.On("UpdateAddress",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_UpdateAddress_Call) Run(run func(ctx context.Context, in *user.UpdateAddressRequest, opts ...grpc.CallOption)) *User_UpdateAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.UpdateAddressRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_UpdateAddress_Call) Return(_a0 *user.UpdateAddressResponse, _a1 error) *User_UpdateAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_UpdateAddress_Call) RunAndReturn(run func(context.Context, *user.UpdateAddressRequest, ...grpc.CallOption) (*user.UpdateAddressResponse, error)) *User_UpdateAddress_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserInfo provides a mock function with given fields: ctx, in, opts
func (_m *User) UpdateUserInfo(ctx context.Context, in *user.UpdateUserInfoRequest, opts ...grpc.CallOption) (*user.UpdateUserInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserInfo")
	}

	var r0 *user.UpdateUserInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.UpdateUserInfoRequest, ...grpc.CallOption) (*user.UpdateUserInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.UpdateUserInfoRequest, ...grpc.CallOption) *user.UpdateUserInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.UpdateUserInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.UpdateUserInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_UpdateUserInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserInfo'
type User_UpdateUserInfo_Call struct {
	*mock.Call
}

// UpdateUserInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.UpdateUserInfoRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) UpdateUserInfo(ctx interface{}, in interface{}, opts ...interface{}) *User_UpdateUserInfo_Call {
	return &User_UpdateUserInfo_Call{Call: _e.mock.On("UpdateUserInfo",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_UpdateUserInfo_Call) Run(run func(ctx context.Context, in *user.UpdateUserInfoRequest, opts ...grpc.CallOption)) *User_UpdateUserInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.UpdateUserInfoRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_UpdateUserInfo_Call) Return(_a0 *user.UpdateUserInfoResponse, _a1 error) *User_UpdateUserInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_UpdateUserInfo_Call) RunAndReturn(run func(context.Context, *user.UpdateUserInfoRequest, ...grpc.CallOption) (*user.UpdateUserInfoResponse, error)) *User_UpdateUserInfo_Call {
	_c.Call.Return(run)
	return _c
}

// WithdrawWallet provides a mock function with given fields: ctx, in, opts
func (_m *User) WithdrawWallet(ctx context.Context, in *user.WithdrawWalletRequest, opts ...grpc.CallOption) (*user.WithdrawWalletResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawWallet")
	}

	var r0 *user.WithdrawWalletResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *user.WithdrawWalletRequest, ...grpc.CallOption) (*user.WithdrawWalletResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *user.WithdrawWalletRequest, ...grpc.CallOption) *user.WithdrawWalletResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.WithdrawWalletResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *user.WithdrawWalletRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// User_WithdrawWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithdrawWallet'
type User_WithdrawWallet_Call struct {
	*mock.Call
}

// WithdrawWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - in *user.WithdrawWalletRequest
//   - opts ...grpc.CallOption
func (_e *User_Expecter) WithdrawWallet(ctx interface{}, in interface{}, opts ...interface{}) *User_WithdrawWallet_Call {
	return &User_WithdrawWallet_Call{Call: _e.mock.On("WithdrawWallet",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *User_WithdrawWallet_Call) Run(run func(ctx context.Context, in *user.WithdrawWalletRequest, opts ...grpc.CallOption)) *User_WithdrawWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*user.WithdrawWalletRequest), variadicArgs...)
	})
	return _c
}

func (_c *User_WithdrawWallet_Call) Return(_a0 *user.WithdrawWalletResponse, _a1 error) *User_WithdrawWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *User_WithdrawWallet_Call) RunAndReturn(run func(context.Context, *user.WithdrawWalletRequest, ...grpc.CallOption) (*user.WithdrawWalletResponse, error)) *User_WithdrawWallet_Call {
	_c.Call.Return(run)
	return _c
}

// NewUser creates a new instance of User. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUser(t interface {
	mock.TestingT
	Cleanup(func())
}) *User {
	mock := &User{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
